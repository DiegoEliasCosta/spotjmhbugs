<?xml version="1.0" encoding="UTF-8"?>
<MessageCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:noNamespaceSchemaLocation="messagecollection.xsd">

	<Plugin>
		<ShortDescription>My SpotBugs Plugin</ShortDescription>
		<Details>This plugin provides original detectors</Details>
	</Plugin>

	<Detector
		class="de.heidelberg.pvs.diego.detectors.IgnoredMethodReturnDetector">
		<Details>
			Detector of the JMH_IGNORED_METHOD_RETURN bug pattern.
		</Details>
	</Detector>

	<Detector class="de.heidelberg.pvs.diego.detectors.StateFinalFieldDetector">
		<Details>
			Detector of the JMH_STATE_FINAL_FIELD bug pattern.
		</Details>
	</Detector>

	<Detector
		class="de.heidelberg.pvs.diego.detectors.LoopInsideBenchmarkDetector">
		<Details>
			Detector of the JMH_LOOP_INSIDE_BENCHMARK inside the
			benchmark bug pattern.
		</Details>
	</Detector>
	
	<Detector
		class="de.heidelberg.pvs.diego.detectors.UnforkedBenchmarkDetector">
		<Details>
			Detector of the JMH_UNFORKED_BENCHMARK inside the
			benchmark bug pattern.
		</Details>
	</Detector>



	<BugPattern type="JMH_IGNORED_METHOD_RETURN">
		<ShortDescription>Method return not used or consumed by a Blackhole.</ShortDescription>
		<LongDescription>Method return not used or consumed in {1}</LongDescription>
		<Details>
<![CDATA[
<p>Each non-void method call should have its return either used in the benchmark or consumed 
by a Blackhole to avoid	dead-code optimization.</p>
]]>
		</Details>
	</BugPattern>

	<BugPattern type="JMH_STATE_FINAL_FIELD">
		<ShortDescription>JMH State field declared final.</ShortDescription>
		<LongDescription>JMH State {2} declared final in {1}</LongDescription>
		<Details>
<![CDATA[
<p>Final fields pose a threat to benchmark measurements
as it gives the compiler the possibility of applying the
constant-folding. If JVM realizes the result of the computation is the
same no matter what, it can cleverly optimize it. In the case of a JMH benchmark, that means
it can move the computation outside of the internal JMH loop.</p>
]]>
		</Details>
	</BugPattern>


	<BugPattern type="JMH_LOOP_INSIDE_BENCHMARK">
		<ShortDescription>Usage of loops in the JMH benchmark function.</ShortDescription>
		<LongDescription>Usage of loops in the benchmark {1}</LongDescription>
		<Details>
<![CDATA[
<p>Looping is done in the hope of minimizing the overhead of calling the test method, by doing the operations inside
the loop instead of inside the method call. This is a dangerous setting for a micro-benchmark.
The compiler can automagically apply some optimizations to merge the loop iterations.</p>
]]>
		</Details>
	</BugPattern>


<BugPattern type="JMH_UNFORKED_BENCHMARK">
		<ShortDescription>Benchmark configured with zero forks.</ShortDescription>
		<LongDescription>Benchmark configured with zero forks in {1}.</LongDescription>
		<Details>
<![CDATA[
<p>
JVMs are notoriously good at profile-guided optimizations. This is bad
for benchmarks, because different tests can mix their profiles together,
and then render the "uniformly bad" code for every test. Forking (running
in a separate process) each test can help to evade this issue.
</p>
]]>
		</Details>
	</BugPattern>


</MessageCollection>
